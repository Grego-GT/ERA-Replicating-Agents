/**
 * FBI Prep - Agent File Preparation
 * 
 * Handles all file I/O operations for agent creation:
 * - Creating agent directories
 * - Writing agent code files
 * - Saving metadata and history
 * - Formatting code with headers
 * 
 * This separates file operations from orchestration logic,
 * making FBI orchestrator usable from CLI, API, tests, or any context.
 */

import { exists } from 'https://deno.land/std@0.208.0/fs/mod.ts';
import { join } from 'https://deno.land/std@0.208.0/path/mod.ts';
import type { AgentCreationHistory } from '../history.ts';
import type { OrchestratorResult } from './fbi.ts';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Options for preparing agent files
 */
export interface PrepOptions {
  /** Base directory for agents (default: 'agents') */
  baseDir?: string;
  /** Whether to overwrite existing agents (default: true) */
  overwrite?: boolean;
  /** Whether to add AI generation header to code (default: true) */
  addHeader?: boolean;
}

/**
 * Result of agent file preparation
 */
export interface PrepResult {
  success: boolean;
  agentName: string;
  files: {
    indexFile: string;
    metadataFile: string;
  };
  paths: {
    agentDir: string;
    indexPath: string;
    metadataPath: string;
  };
  error?: string;
}

// ============================================================================
// Code Formatting
// ============================================================================

/**
 * Format AI-generated code with header metadata
 */
export function formatAIGeneratedCode(
  name: string,
  promptText: string,
  generatedCode: string,
  metadata: {
    model?: string;
    attempts?: number;
    timestamp?: string;
  }
): string {
  const header = `/**
 * Agent: ${name}
 * Prompt: ${promptText}
 * 
 * This code was generated by AI using Wandb + Daytona
 * Model: ${metadata.model || 'Unknown'}
 * Generated: ${metadata.timestamp || new Date().toISOString()}
 * Attempts: ${metadata.attempts || 1}
 */

`;

  return header + generatedCode;
}


// ============================================================================
// File Operations
// ============================================================================

/**
 * Prepare agent files from orchestrator result
 * 
 * Creates directory structure and writes:
 * - index.ts (formatted agent code)
 * - agent.json (metadata with history)
 */
export async function prepareAgentFiles(
  result: OrchestratorResult,
  options: PrepOptions = {}
): Promise<PrepResult> {
  const {
    baseDir = 'agents',
    overwrite = true,
    addHeader = true
  } = options;

  const agentName = result.history.agentName;
  const promptText = result.prompt;

  try {
    // Create base agents directory if it doesn't exist
    const agentsDir = join(Deno.cwd(), baseDir);
    if (!(await exists(agentsDir))) {
      await Deno.mkdir(agentsDir, { recursive: true });
    }

    // Create agent-specific directory
    const agentDir = join(agentsDir, agentName);
    if (await exists(agentDir)) {
      if (!overwrite) {
        return {
          success: false,
          agentName,
          files: {
            indexFile: `${baseDir}/${agentName}/index.ts`,
            metadataFile: `${baseDir}/${agentName}/agent.json`
          },
          paths: {
            agentDir,
            indexPath: join(agentDir, 'index.ts'),
            metadataPath: join(agentDir, 'agent.json')
          },
          error: `Agent "${agentName}" already exists`
        };
      }
    } else {
      await Deno.mkdir(agentDir, { recursive: true });
    }

    // Format the generated code
    const agentCode = addHeader
      ? formatAIGeneratedCode(agentName, promptText, result.generation.code, {
          model: result.generation.model,
          attempts: result.generation.attempts,
          timestamp: result.history.timestamp
        })
      : result.generation.code;

    // Write index.ts
    const indexPath = join(agentDir, 'index.ts');
    await Deno.writeTextFile(indexPath, agentCode);

    // Write agent.json (metadata)
    const metadataPath = join(agentDir, 'agent.json');
    await Deno.writeTextFile(metadataPath, JSON.stringify(result.history, null, 2));

    return {
      success: true,
      agentName,
      files: {
        indexFile: `${baseDir}/${agentName}/index.ts`,
        metadataFile: `${baseDir}/${agentName}/agent.json`
      },
      paths: {
        agentDir,
        indexPath,
        metadataPath
      }
    };

  } catch (error) {
    const err = error as Error;
    return {
      success: false,
      agentName,
      files: {
        indexFile: `${baseDir}/${agentName}/index.ts`,
        metadataFile: `${baseDir}/${agentName}/agent.json`
      },
      paths: {
        agentDir: join(Deno.cwd(), baseDir, agentName),
        indexPath: join(Deno.cwd(), baseDir, agentName, 'index.ts'),
        metadataPath: join(Deno.cwd(), baseDir, agentName, 'agent.json')
      },
      error: err.message
    };
  }
}


