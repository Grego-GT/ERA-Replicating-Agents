/**
 * FBI Prep - Agent File Preparation
 * 
 * Handles all file I/O operations for agent creation:
 * - Creating agent directories
 * - Writing agent code files
 * - Saving metadata and history
 * - Formatting code with headers
 * 
 * This separates file operations from orchestration logic,
 * making ERA orchestrator usable from CLI, API, tests, or any context.
 */

import { exists } from 'https://deno.land/std@0.208.0/fs/mod.ts';
import { join } from 'https://deno.land/std@0.208.0/path/mod.ts';
import type { AgentCreationHistory } from '../history.ts';
import type { OrchestratorResult } from './fbi.ts';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Options for preparing agent files
 */
export interface PrepOptions {
  /** Base directory for agents (default: 'agents') */
  baseDir?: string;
  /** Whether to overwrite existing agents (default: true) */
  overwrite?: boolean;
  /** Whether to add AI generation header to code (default: true) */
  addHeader?: boolean;
  /** Existing agent history to merge with (for continuations) */
  existingHistory?: AgentCreationHistory;
}

/**
 * Result of agent file preparation
 */
export interface PrepResult {
  success: boolean;
  agentName: string;
  files: {
    indexFile: string;
    metadataFile: string;
    iterationFiles?: string[]; // List of saved iteration files
  };
  paths: {
    agentDir: string;
    indexPath: string;
    metadataPath: string;
    iterationsDir?: string;
  };
  error?: string;
}

// ============================================================================
// Code Formatting
// ============================================================================

/**
 * Format AI-generated code with header metadata
 */
export function formatAIGeneratedCode(
  name: string,
  promptText: string,
  generatedCode: string,
  metadata: {
    model?: string;
    attempts?: number;
    timestamp?: string;
  }
): string {
  const header = `/**
 * Agent: ${name}
 * Prompt: ${promptText}
 * 
 * This code was generated by AI using Wandb + Daytona
 * Model: ${metadata.model || 'Unknown'}
 * Generated: ${metadata.timestamp || new Date().toISOString()}
 * Attempts: ${metadata.attempts || 1}
 */

`;

  return header + generatedCode;
}


// ============================================================================
// File Operations
// ============================================================================

/**
 * Prepare agent files from orchestrator result
 * 
 * Creates directory structure and writes:
 * - index.ts (formatted agent code - latest/best version)
 * - agent.json (metadata with ALL history)
 * - iterations/ folder with timestamped snapshots of each attempt
 */
export async function prepareAgentFiles(
  result: OrchestratorResult,
  options: PrepOptions = {}
): Promise<PrepResult> {
  const {
    baseDir = 'agents',
    overwrite = true,
    addHeader = true,
    existingHistory
  } = options;

  const agentName = result.history.agentName;
  const promptText = result.prompt;

  try {
    // Create base agents directory if it doesn't exist
    const agentsDir = join(Deno.cwd(), baseDir);
    if (!(await exists(agentsDir))) {
      await Deno.mkdir(agentsDir, { recursive: true });
    }

    // Create agent-specific directory
    const agentDir = join(agentsDir, agentName);
    if (await exists(agentDir)) {
      if (!overwrite) {
        return {
          success: false,
          agentName,
          files: {
            indexFile: `${baseDir}/${agentName}/index.ts`,
            metadataFile: `${baseDir}/${agentName}/agent.json`
          },
          paths: {
            agentDir,
            indexPath: join(agentDir, 'index.ts'),
            metadataPath: join(agentDir, 'agent.json')
          },
          error: `Agent "${agentName}" already exists`
        };
      }
    } else {
      await Deno.mkdir(agentDir, { recursive: true });
    }
    
    // Merge with existing history if this is a continuation
    let mergedHistory = result.history;
    if (existingHistory) {
      console.log(colorize('ðŸ”— Merging with existing agent history...', 'cyan'));
      
      // Calculate global attempt numbers for this session
      const previousTotalAttempts = existingHistory.sessions
        ? existingHistory.sessions.reduce((sum, s) => sum + s.attempts.length, 0)
        : (existingHistory.attempts?.length || 0); // Backward compat
      
      // Create new session with attempts nested inside
      const newSessionInfo = {
        sessionNumber: (existingHistory.sessions?.length || 0) + 1,
        timestamp: result.history.timestamp,
        prompt: promptText,
        attempts: (result.history.attempts || []).map((attempt, idx) => ({
          ...attempt,
          attemptNumber: previousTotalAttempts + idx + 1  // Global sequential numbering
        }))
      };
      
      // Keep original metadata but append new session
      mergedHistory = {
        ...existingHistory,
        // Update these fields with latest run
        timestamp: result.history.timestamp,
        finalCode: result.history.finalCode,
        wasExecuted: result.history.wasExecuted,
        error: result.history.error,
        stackTrace: result.history.stackTrace,
        agentDescription: result.history.agentDescription || existingHistory.agentDescription,
        
        // Build sessions array
        sessions: [
          ...(existingHistory.sessions || [
            // If no sessions array yet (old format), convert old data to session format
            {
              sessionNumber: 1,
              timestamp: existingHistory.timestamp,
              prompt: existingHistory.ogprompt,
              attempts: existingHistory.attempts || []
            }
          ]),
          newSessionInfo  // Add new session with nested attempts
        ],
        
        // Keep top-level attempts for backward compatibility, but mark as deprecated
        attempts: [
          ...(existingHistory.attempts || []),
          ...newSessionInfo.attempts
        ]
      };
      
      const totalAttempts = mergedHistory.sessions?.reduce((sum, s) => sum + s.attempts.length, 0) || 0;
      console.log(colorize(`   Total sessions: ${mergedHistory.sessions?.length || 0}`, 'gray'));
      console.log(colorize(`   Total attempts: ${totalAttempts}`, 'gray'));
      console.log(colorize(`   This session: ${newSessionInfo.attempts.length} attempt(s)`, 'gray'));
    }
    
    function colorize(text: string, color: string): string {
      // Simple fallback if colors not imported
      return text;
    }

    // Create iterations directory for historical snapshots
    const iterationsDir = join(agentDir, 'iterations');
    if (!(await exists(iterationsDir))) {
      await Deno.mkdir(iterationsDir, { recursive: true });
    }

    // Save each iteration as a timestamped snapshot
    const iterationFiles: string[] = [];
    if (mergedHistory.sessions) {
      // Iterate through sessions and their attempts
      for (const session of mergedHistory.sessions) {
        for (const attempt of session.attempts) {
          if (attempt.extractedCode) {
            // Create a safe filename from timestamp
            const timestamp = new Date(attempt.timestamp).getTime();
            const iterationFilename = `iteration-${attempt.attemptNumber}-${timestamp}.ts`;
            const iterationPath = join(iterationsDir, iterationFilename);
            
            // Format iteration code with metadata header
            const iterationHeader = `/**
 * Iteration ${attempt.attemptNumber} (Session ${session.sessionNumber}) - ${attempt.timestamp}
 * Agent: ${agentName}
 * Session Prompt: ${session.prompt.substring(0, 100)}${session.prompt.length > 100 ? '...' : ''}
 * Extraction Success: ${attempt.extractionSuccess}
 * ${attempt.execution ? `Execution Success: ${attempt.execution.success}` : 'Not executed'}
 * 
 * Full Prompt:
 * ${attempt.prompt ? attempt.prompt.substring(0, 200) + '...' : session.prompt}
 */

`;
            
            const iterationCode = iterationHeader + attempt.extractedCode;
            await Deno.writeTextFile(iterationPath, iterationCode);
            
            iterationFiles.push(`${baseDir}/${agentName}/iterations/${iterationFilename}`);
          }
        }
      }
    } else if (mergedHistory.attempts) {
      // Backward compatibility: if no sessions yet, use old attempts array
      for (const attempt of mergedHistory.attempts) {
        if (attempt.extractedCode) {
          const timestamp = new Date(attempt.timestamp).getTime();
          const iterationFilename = `iteration-${attempt.attemptNumber}-${timestamp}.ts`;
          const iterationPath = join(iterationsDir, iterationFilename);
          
          const iterationHeader = `/**
 * Iteration ${attempt.attemptNumber} - ${attempt.timestamp}
 * Agent: ${agentName}
 * Extraction Success: ${attempt.extractionSuccess}
 * ${attempt.execution ? `Execution Success: ${attempt.execution.success}` : 'Not executed'}
 */

`;
          
          const iterationCode = iterationHeader + attempt.extractedCode;
          await Deno.writeTextFile(iterationPath, iterationCode);
          
          iterationFiles.push(`${baseDir}/${agentName}/iterations/${iterationFilename}`);
        }
      }
    }

    // Format the final generated code (latest/best version)
    // Use the user's prompt (not the full continuation context)
    const displayPrompt = result.prompt;
    const agentCode = addHeader
      ? formatAIGeneratedCode(agentName, displayPrompt, result.generation.code, {
          model: result.generation.model,
          attempts: result.generation.attempts,
          timestamp: result.history.timestamp
        })
      : result.generation.code;

    // Write index.ts (current/best version)
    const indexPath = join(agentDir, 'index.ts');
    await Deno.writeTextFile(indexPath, agentCode);

    // Write agent.json (metadata with ALL history - merged if continuation)
    const metadataPath = join(agentDir, 'agent.json');
    await Deno.writeTextFile(metadataPath, JSON.stringify(mergedHistory, null, 2));

    console.log(`ðŸ“¦ Saved ${iterationFiles.length} iteration snapshot(s) to ${baseDir}/${agentName}/iterations/`);

    return {
      success: true,
      agentName,
      files: {
        indexFile: `${baseDir}/${agentName}/index.ts`,
        metadataFile: `${baseDir}/${agentName}/agent.json`,
        iterationFiles
      },
      paths: {
        agentDir,
        indexPath,
        metadataPath,
        iterationsDir
      }
    };

  } catch (error) {
    const err = error as Error;
    return {
      success: false,
      agentName,
      files: {
        indexFile: `${baseDir}/${agentName}/index.ts`,
        metadataFile: `${baseDir}/${agentName}/agent.json`
      },
      paths: {
        agentDir: join(Deno.cwd(), baseDir, agentName),
        indexPath: join(Deno.cwd(), baseDir, agentName, 'index.ts'),
        metadataPath: join(Deno.cwd(), baseDir, agentName, 'agent.json')
      },
      error: err.message
    };
  }
}


